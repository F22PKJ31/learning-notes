<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>雪花算法（SnowFlake）Java 实现 - 简书 | Learning Notes</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="My learning notes">
    <meta name="referrer" content="no-referrer">
    
    <link rel="preload" href="/learning-notes/assets/css/0.styles.d266b3be.css" as="style"><link rel="preload" href="/learning-notes/assets/js/app.e71e9f8a.js" as="script"><link rel="preload" href="/learning-notes/assets/js/2.f8bbc37d.js" as="script"><link rel="preload" href="/learning-notes/assets/js/10.b0664fb5.js" as="script"><link rel="prefetch" href="/learning-notes/assets/js/11.646d2ddd.js"><link rel="prefetch" href="/learning-notes/assets/js/12.5bd9e64d.js"><link rel="prefetch" href="/learning-notes/assets/js/13.160753b0.js"><link rel="prefetch" href="/learning-notes/assets/js/14.cee609b1.js"><link rel="prefetch" href="/learning-notes/assets/js/3.5d8d4485.js"><link rel="prefetch" href="/learning-notes/assets/js/4.09fd2c39.js"><link rel="prefetch" href="/learning-notes/assets/js/5.fc791712.js"><link rel="prefetch" href="/learning-notes/assets/js/6.ffe6f60a.js"><link rel="prefetch" href="/learning-notes/assets/js/7.9aa5aca5.js"><link rel="prefetch" href="/learning-notes/assets/js/8.641032d3.js"><link rel="prefetch" href="/learning-notes/assets/js/9.4d3f4124.js">
    <link rel="stylesheet" href="/learning-notes/assets/css/0.styles.d266b3be.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/learning-notes/" class="home-link router-link-active"><!----> <span class="site-name">Learning Notes</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Mysql</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/learning-notes/mysql/" aria-current="page" class="sidebar-link">MySQL</a></li><li><a href="/learning-notes/mysql/mysql-fen-ku-fen-biao-wei-yi-zhu-jian-shi-xian-fang-an.html" class="sidebar-link">MySQL分库分表唯一主键实现方案</a></li><li><a href="/learning-notes/mysql/xue-hua-suan-fa-snowflakejava-shi-xian.html" aria-current="page" class="active sidebar-link">雪花算法（SnowFlake）Java 实现 - 简书</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/learning-notes/mysql/xue-hua-suan-fa-snowflakejava-shi-xian.html#算法原理" class="sidebar-link">算法原理</a></li><li class="sidebar-sub-header"><a href="/learning-notes/mysql/xue-hua-suan-fa-snowflakejava-shi-xian.html#算法实现-java" class="sidebar-link">算法实现（Java）</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>未分类</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="雪花算法-snowflake-java-实现-简书"><a href="#雪花算法-snowflake-java-实现-简书" class="header-anchor">#</a> 雪花算法（SnowFlake）Java 实现 - 简书</h1> <blockquote><p>本文由 <a href="http://ksria.com/simpread/" target="_blank" rel="noopener noreferrer">简悦 SimpRead<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 转码， 原文地址 <a href="https://www.jianshu.com/p/2a27fbd9e71a" target="_blank" rel="noopener noreferrer">www.jianshu.com<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>分布式 id 生成算法的有很多种，Twitter 的 SnowFlake 就是其中经典的一种。</p></blockquote> <h2 id="算法原理"><a href="#算法原理" class="header-anchor">#</a> 算法原理</h2> <p>SnowFlake 算法生成 id 的结果是一个 64bit 大小的整数，它的结构如下图：</p> <p><img src="http://upload-images.jianshu.io/upload_images/13382703-b64e38457ddd13e2.jpg" alt=""> 结构图</p> <ol><li><strong>1bit</strong>，不用，因为二进制中最高位是符号位，1 表示负数，0 表示正数。生成的 id 一般都是用整数，所以最高位固定为 0。</li> <li><strong>41bit - 时间戳</strong>，用来记录时间戳，毫秒级。
<ul><li>41 位可以表示<img src="https://math.jianshu.com/math?formula=2%5E%7B41%7D-1" alt="">个数字，</li> <li>如果只用来表示正整数（计算机中正数包含 0），可以表示的数值范围是：0 至 <img src="https://math.jianshu.com/math?formula=2%5E%7B41%7D-1" alt="">，减 1 是因为可表示的数值范围是从 0 开始算的，而不是 1。</li> <li>也就是说 41 位可以表示<img src="https://math.jianshu.com/math?formula=2%5E%7B41%7D-1" alt="">个毫秒的值，转化成单位年则是![](<a href="https://math.jianshu.com/math?formula=%282%5E%7B41%7D-1%29%20%2F%20%281000%20*%2060%20*%2060%20*%2024%20*365%29%20%3D%2069%29%E5%B9%B4" target="_blank" rel="noopener noreferrer">https://math.jianshu.com/math?formula=(2%5E%7B41%7D-1) %2F (1000 * 60 * 60 * 24 *365) %3D 69)年<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li> <li><strong>10bit - 工作机器 id</strong>，用来记录工作机器 id。
<ul><li>可以部署在<img src="https://math.jianshu.com/math?formula=2%5E%7B10%7D%20%3D%201024" alt="">个节点，包括 5 位 datacenterId 和 5 位 workerId</li> <li>5 位（bit）可以表示的最大正整数是<img src="https://math.jianshu.com/math?formula=2%5E%7B5%7D-1%20%3D%2031" alt="">，即可以用 0、1、2、3、....31 这 32 个数字，来表示不同的 datecenterId 或 workerId</li></ul></li> <li><strong>12bit - 序列号</strong>，序列号，用来记录同毫秒内产生的不同 id。
<ul><li>12 位（bit）可以表示的最大正整数是<img src="https://math.jianshu.com/math?formula=2%5E%7B12%7D-1%20%3D%204095" alt="">，即可以用 0、1、2、3、....4094 这 4095 个数字，来表示同一机器同一时间截（毫秒) 内产生的 4095 个 ID 序号。</li></ul></li></ol> <p>由于在 Java 中 64bit 的整数是 long 类型，所以在 Java 中 SnowFlake 算法生成的 id 就是 long 来存储的。</p> <p><strong>SnowFlake 可以保证：</strong></p> <blockquote><ol><li>所有生成的 id 按时间趋势递增</li> <li>整个分布式系统内不会产生重复 id（因为有 datacenterId 和 workerId 来做区分）</li></ol></blockquote> <h2 id="算法实现-java"><a href="#算法实现-java" class="header-anchor">#</a> 算法实现（Java）</h2> <p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Ftwitter-archive%2Fsnowflake%2Fblob%2Fsnowflake-2010%2Fsrc%2Fmain%2Fscala%2Fcom%2Ftwitter%2Fservice%2Fsnowflake%2FIdWorker.scala" target="_blank" rel="noopener noreferrer">Twitter 官方给出的算法实现<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 是用 Scala 写的，这里不做分析，可自行查看。</p> <p>Java 版算法实现：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000011282426" target="_blank" rel="noopener noreferrer">搬运自煲煲菜的博客<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language-text extra-class"><pre class="language-text"><code>public class IdWorker{

    //下面两个每个5位，加起来就是10位的工作机器id
    private long workerId;    //工作id
    private long datacenterId;   //数据id
    //12位的序列号
    private long sequence;

    public IdWorker(long workerId, long datacenterId, long sequence){
        // sanity check for workerId
        if (workerId &gt; maxWorkerId || workerId &lt; 0) {
            throw new IllegalArgumentException(String.format(&quot;worker Id can't be greater than %d or less than 0&quot;,maxWorkerId));
        }
        if (datacenterId &gt; maxDatacenterId || datacenterId &lt; 0) {
            throw new IllegalArgumentException(String.format(&quot;datacenter Id can't be greater than %d or less than 0&quot;,maxDatacenterId));
        }
        System.out.printf(&quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&quot;,
                timestampLeftShift, datacenterIdBits, workerIdBits, sequenceBits, workerId);

        this.workerId = workerId;
        this.datacenterId = datacenterId;
        this.sequence = sequence;
    }

    //初始时间戳
    private long twepoch = 1288834974657L;

    //长度为5位
    private long workerIdBits = 5L;
    private long datacenterIdBits = 5L;
    //最大值
    private long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits);
    private long maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits);
    //序列号id长度
    private long sequenceBits = 12L;
    //序列号最大值
    private long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits);

    //工作id需要左移的位数，12位
    private long workerIdShift = sequenceBits;
   //数据id需要左移位数 12+5=17位
    private long datacenterIdShift = sequenceBits + workerIdBits;
    //时间戳需要左移位数 12+5+5=22位
    private long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;

    //上次时间戳，初始值为负数
    private long lastTimestamp = -1L;

    public long getWorkerId(){
        return workerId;
    }

    public long getDatacenterId(){
        return datacenterId;
    }

    public long getTimestamp(){
        return System.currentTimeMillis();
    }

     //下一个ID生成算法
    public synchronized long nextId() {
        long timestamp = timeGen();

        //获取当前时间戳如果小于上次时间戳，则表示时间戳获取出现异常
        if (timestamp &lt; lastTimestamp) {
            System.err.printf(&quot;clock is moving backwards.  Rejecting requests until %d.&quot;, lastTimestamp);
            throw new RuntimeException(String.format(&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;,
                    lastTimestamp - timestamp));
        }

        //获取当前时间戳如果等于上次时间戳（同一毫秒内），则在序列号加一；否则序列号赋值为0，从0开始。
        if (lastTimestamp == timestamp) {
            sequence = (sequence + 1) &amp; sequenceMask;
            if (sequence == 0) {
                timestamp = tilNextMillis(lastTimestamp);
            }
        } else {
            sequence = 0;
        }

        //将上次时间戳值刷新
        lastTimestamp = timestamp;

        /**
          * 返回结果：
          * (timestamp - twepoch) &lt;&lt; timestampLeftShift) 表示将时间戳减去初始时间戳，再左移相应位数
          * (datacenterId &lt;&lt; datacenterIdShift) 表示将数据id左移相应位数
          * (workerId &lt;&lt; workerIdShift) 表示将工作id左移相应位数
          * | 是按位或运算符，例如：x | y，只有当x，y都为0的时候结果才为0，其它情况结果都为1。
          * 因为个部分只有相应位上的值有意义，其它位上都是0，所以将各部分的值进行 | 运算就能得到最终拼接好的id
        */
        return ((timestamp - twepoch) &lt;&lt; timestampLeftShift) |
                (datacenterId &lt;&lt; datacenterIdShift) |
                (workerId &lt;&lt; workerIdShift) |
                sequence;
    }

    //获取时间戳，并与上次时间戳比较
    private long tilNextMillis(long lastTimestamp) {
        long timestamp = timeGen();
        while (timestamp &lt;= lastTimestamp) {
            timestamp = timeGen();
        }
        return timestamp;
    }

    //获取系统时间戳
    private long timeGen(){
        return System.currentTimeMillis();
    }

    //---------------测试---------------
    public static void main(String[] args) {
        IdWorker worker = new IdWorker(1,1,1);
        for (int i = 0; i &lt; 30; i++) {
            System.out.println(worker.nextId());
        }
    }

}
</code></pre></div><p>算法中大量使用位运算，这里不对位运算做过多解释，代码的详细解释参考<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000011282426" target="_blank" rel="noopener noreferrer">煲煲菜的博客<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <blockquote><p>文章主要摘抄自<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000011282426" target="_blank" rel="noopener noreferrer">煲煲菜的博客<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><br>
如有侵权之处请留言告知，会立即删除。</p></blockquote></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/learning-notes/mysql/mysql-fen-ku-fen-biao-wei-yi-zhu-jian-shi-xian-fang-an.html" class="prev">
        MySQL分库分表唯一主键实现方案
      </a></span> <span class="next"><a href="/learning-notes/未分类/MVCC 多版本并发控制 - 简书.html">
        MVCC 多版本并发控制 - 简书
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/learning-notes/assets/js/app.e71e9f8a.js" defer></script><script src="/learning-notes/assets/js/2.f8bbc37d.js" defer></script><script src="/learning-notes/assets/js/10.b0664fb5.js" defer></script>
  </body>
</html>
