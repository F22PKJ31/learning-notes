# MySQL分库分表唯一主键实现方案

## 摘要

数据库分库分表同时因为服务是多节点部署的，所以就会引申出分布式系统中唯一主键 ID 的生成问题。一般我们唯一 ID 的有以下特性：

> * 整个系统 ID 唯一
> * ID 是数字类型，而且是趋势递增的
> * ID 简短，查询效率快

下面我们看下常见的几种 ID 生成方式

## UUID/GUID

使用 guid 或者 uuid 作为主键 id  
**优点**

1. 代码实现简单。
2. 本机生成，没有性能问题
3. 因为是全球唯一的 ID，所以迁移数据容易

**缺点**

1. 每次生成的 ID 是无序的，无法保证趋势递增
2. UUID 的字符串存储，查询效率慢
3. 存储空间大
4. ID 无业务含义，不可读

## MySQL 主键自增

这个方案就是利用了 MySQL 的主键自增 auto\_increment，默认每次 ID 加 1。对于我们分表的业务场景中通过卫不同的表设置不同的步长以及初始值实现。  
![](https://img-blog.csdnimg.cn/20200330141838604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQzOTU5NTU=,size_16,color_FFFFFF,t_70#pic_center)  
**优点**

1. 数字化，id 递增
2. 查询效率高
3. 具有一定的业务可读

**缺点**

1. 存在单点问题，如果 mysql 挂了，就没法生成 iD 了
2. 数据库压力大，高并发抗不住

## 雪花算法

雪花算法生成 64 位的二进制正整数，然后转换成 10 进制的数。64 位二进制数由如下部分组成：  
![](https://img-blog.csdnimg.cn/20200330142056922.png#pic_center)

> * 1 位标识符：始终是 0
> * 41 位时间戳：41 位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截 \) 得到的值，这里的的开始时间截，一般是我们的 id 生成器开始使用的时间，由我们程序来指定的
> * 10 位机器标识码：可以部署在 1024 个节点，如果机器分机房（IDC）部署，这 10 位可以由 5 位机房 ID + 5 位机器 ID 组成
> * 12 位序列：毫秒内的计数，12 位的计数顺序号支持每个节点每毫秒 \(同一机器，同一时间截\) 产生 4096 个 ID 序号

**优点**

1. 此方案每秒能够产生 409.6 万个 ID，性能快
2. 时间戳在高位，自增序列在低位，整个 ID 是趋势递增的，按照时间有序递增
3. 灵活度高，可以根据业务需求，调整 bit 位的划分，满足不同的需求

**缺点**

1. 依赖机器的时钟，如果服务器时钟回拨，会导致重复 ID 生成

## Redis 生成方案

利用 redis 的 incr 原子性操作自增，一般算法为：

> 年份 + 当天距当年第多少天 + 天数 + 小时 + redis 自增

**优点**

1. 有序递增，可读性强

**缺点**

1. 占用带宽，每次要向 redis 进行请求

## 应用

由于我们存在高并发场景，而且期望 id 是去世递增，所以上述方法都不能完全适用我们的业务场景。我们选择改造自增主键的方式。  
**改造数据库主键自增**  
自增主键有两个问题：

1. 一旦步长定下来，不容易扩容
2. 数据库压力大

为什么压力大？是因为我们每次获取 ID 的时候，都要去数据库请求一次。那我们可以不可以不要每次去取？思路我们可以请求数据库得到 ID 的时候，可设计成获得的 ID 是一个 ID 区间段。  
![](https://img-blog.csdnimg.cn/20200330145003393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQzOTU5NTU=,size_16,color_FFFFFF,t_70#pic_center)  
这种方式如果多个节点同时发起请求获取 id 区间会有并发问题，所以需要加锁，可以通过分布式锁或者数据库自身的锁解决。虽然加锁可以解决并发问题但是还是会有阻塞问题。此时可以通过双 buffer 缓存解决。  
**双 buffer 方案**  
![](https://img-blog.csdnimg.cn/202003301505220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQzOTU5NTU=,size_16,color_FFFFFF,t_70#pic_center)

> 1、当前获取 ID 在 buffer1 中，每次获取 ID 在 buffer1 中获取  
> 2、当 buffer1 中的 Id 已经使用到了 100，也就是达到区间的 70%  
> 3、达到了 70%，先判断 buffer2 中有没有去获取过，如果没有就立即发起请求获取 ID 线程，此线程把获取到的 ID，设置到 buffer2 中。  
> 4、如果 buffer1 用完了，buffer2 会升级到 buffer1  
> 6、依次往返

这样不仅达到了业务场景用的 ID，都是在 jvm 内存中获得的，从此不需要到数据库中获取了。允许数据库宕机时间更长了。而且因为会有一个线程，会观察什么时候去自动获取。两个 buffer 之间自行切换使用。就解决了突发阻塞的问题。

